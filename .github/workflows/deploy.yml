name: Build and Deploy to EKS

on:
  push:
    branches:
      - main
  pull_request:
    branches:
      - main

env:
  AWS_REGION: us-east-1
  ECR_REPOSITORY: sample-python-app
  EKS_CLUSTER_NAME: sample-python-app-cluster
  # AWS_ACCESS_KEY_ID: ${{ secrets.AWS_ACCESS_KEY_ID }}
  # AWS_SECRET_ACCESS_KEY: ${{ secrets.AWS_SECRET_ACCESS_KEY }}

jobs:
  build-and-push:
    name: Build and Push Docker Image
    runs-on: ubuntu-latest
    
    permissions:
      id-token: write
      contents: read
    
    outputs:
      image-tag: ${{ steps.image-tag.outputs.tag }}
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        # role-to-assume: ${{ secrets.AWS_ROLE_ARN }}
        aws-region: ${{ env.AWS_REGION }}

    - name: Login to Amazon ECR
      id: login-ecr
      uses: aws-actions/amazon-ecr-login@v2

    - name: Set image tag
      id: image-tag
      run: |
        IMAGE_TAG=${{ github.sha }}
        echo "tag=$IMAGE_TAG" >> $GITHUB_OUTPUT
        echo "IMAGE_TAG=$IMAGE_TAG" >> $GITHUB_ENV

    - name: Build Docker image
      run: |
        docker build -f Dockerfile -t ${{ steps.login-ecr.outputs.registry }}/${{ env.ECR_REPOSITORY }}:${{ env.IMAGE_TAG }} .
        docker tag ${{ steps.login-ecr.outputs.registry }}/${{ env.ECR_REPOSITORY }}:${{ env.IMAGE_TAG }} \
                   ${{ steps.login-ecr.outputs.registry }}/${{ env.ECR_REPOSITORY }}:latest

    - name: Push Docker image to ECR
      run: |
        docker push ${{ steps.login-ecr.outputs.registry }}/${{ env.ECR_REPOSITORY }}:${{ env.IMAGE_TAG }}
        docker push ${{ steps.login-ecr.outputs.registry }}/${{ env.ECR_REPOSITORY }}:latest

  # deploy-to-eks:
  #   name: Deploy to EKS
  #   needs: build-and-push
  #   runs-on: ubuntu-latest
    
  #   permissions:
  #     id-token: write
  #     contents: read
    
  #   steps:
  #   - name: Checkout code
  #     uses: actions/checkout@v4

  #   - name: Configure AWS credentials
  #     uses: aws-actions/configure-aws-credentials@v4
  #     with:
  #       role-to-assume: ${{ secrets.AWS_ROLE_ARN }}
  #       aws-region: ${{ env.AWS_REGION }}

  #   - name: Update kubeconfig
  #     run: |
  #       aws eks update-kubeconfig --name ${{ env.EKS_CLUSTER_NAME }} --region ${{ env.AWS_REGION }}

  #   - name: Deploy to EKS
  #     run: |
  #       kubectl apply -f k8s/deployment.yaml
  #       kubectl rollout status deployment/sample-python-app -n default --timeout=5m

  #   - name: Verify deployment
  #     run: |
  #       kubectl get deployments -n default
  #       kubectl get services -n default
  #       kubectl get hpa -n default
        
  #   - name: Get LoadBalancer URL
  #     run: |
  #       echo "Waiting for LoadBalancer to be ready..."
  #       kubectl wait --for=condition=ready --timeout=300s service/sample-python-app-service -n default || true
  #       LB_URL=$(kubectl get service sample-python-app-service -n default -o jsonpath='{.status.loadBalancer.ingress[0].hostname}')
  #       echo "Application URL: http://$LB_URL"

  deploy-to-eks:
  name: Deploy to EKS
  needs: build-and-push
  runs-on: ubuntu-latest
  
  permissions:
    id-token: write
    contents: read
  
  steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: ${{ env.AWS_REGION }}

    - name: Update kubeconfig
      run: |
        aws eks update-kubeconfig --name ${{ env.EKS_CLUSTER_NAME }} --region ${{ env.AWS_REGION }}

    - name: Deploy to EKS
      run: |
        kubectl apply -f k8s/deployment.yaml
        kubectl rollout status deployment/sample-python-app -n default --timeout=5m

    - name: Verify deployment
      run: |
        kubectl get deployments -n default
        kubectl get services -n default
        kubectl get hpa -n default
        
    - name: Get LoadBalancer URL
      run: |
        echo "Waiting for LoadBalancer to be ready..."
        kubectl wait --for=condition=ready --timeout=300s service/sample-python-app-service -n default || true
        LB_URL=$(kubectl get service sample-python-app-service -n default -o jsonpath='{.status.loadBalancer.ingress[0].hostname}')
        echo "Application URL: http://$LB_URL"